# 日本語教師養成課程「420時間」要件に対応するMoodle次世代LMSアーキテクチャ：厳密な学習時間計測と不正防止のための技術的研究報告書

## 1. 序論：デジタル化された日本語教師養成における「時間」の重み

### 1.1 背景と課題の所在

日本の日本語教育において、文化庁が定める「日本語教員養成において必要とされる教育内容」（いわゆる420時間カリキュラム）は、教育の質を担保するための最も重要な基準の一つである。伝統的に、この420時間の要件は対面授業における「出席」という物理的な拘束時間によって管理されてきた。教室に座り、講師の話を聞き、演習に参加することで、学習者はその時間を「履修」したものとみなされる。しかし、デジタルトランスフォーメーション（DX）の波と、多様な学習ニーズへの対応から、eラーニング（オンデマンド型学習）の導入が急速に進んでいる。

ここで最大の問題となるのが、「学習時間の厳密な証明」である。対面授業であれば、講師や事務局が視覚的に受講者の存在を確認できるが、非同期型のeラーニングにおいて、「画面の前に学習者が存在し、かつ誠実に学習に取り組んでいるか」を証明することは技術的に極めて困難である。単に動画を再生したまま席を外す、ブラウザを最小化して別の作業を行う、あるいは複数の動画を同時に再生して時間を稼ぐといった「不正」や「不誠実な学習態度」は、容易に想像されるリスクである。

従来のLMS（Learning Management System）の多くは、学習の「完了（Completion）」を管理することには長けているが、学習の「プロセス（Process）」や「継続時間（Duration）」を厳密に管理するようには設計されていない。Moodleをはじめとする標準的なLMSは、リソースへのアクセスログやクイズの点数を記録することは得意でも、「そのリソースに、ユーザーが何分何秒、能動的に関与したか」を秒単位で監査可能なレベルで記録する機能は、標準では提供されていない。

本報告書は、このギャップを埋めるための技術的解決策を包括的に提示するものである。具体的には、オープンソースLMSであるMoodleを基盤としつつ、標準機能を凌駕するカスタムプラグインアーキテクチャ、クライアントサイドでの高度なJavaScript制御、そしてVimeoプラットフォームとのAPI連携を駆使し、文化庁の求める厳格な基準に耐えうる「真正な学習時間の計測」と「不正防止」を実現するためのシステム設計論を展開する。

### 1.2 報告書の構成と目的

本報告書は、教育機関のシステム管理者、開発者、および政策担当者を対象としており、以下の技術的課題に対する具体的な実装論を提供する。

1. **既存Moodleの限界分析**: なぜ標準のログ機能や既存プラグインでは420時間要件を満たせないのか、データベース構造とロジックの観点から解析する。
    
2. **ハートビート型計測アーキテクチャ**: Page Visibility APIとJavaScriptを用いた、能動的学習時間のリアルタイム計測手法。
    
3. **動画学習の厳格化**: Vimeo Player APIを用いた、再生速度検知、シーク（早送り）防止、および「実視聴時間」の算出ロジック。
    
4. **不正防止メカニズム**: Broadcast Channel APIによる複数タブ・複数ウィンドウでの同時受講（パラレル受講）の検知と遮断。
    
5. **高負荷対策とデータベース設計**: 秒単位のトラッキングがもたらすデータベース負荷への対策と、カスタムテーブル設計、非同期処理による最適化。
    
6. **本人確認と監査**: プロクタリング（監視）技術との統合による、学習者本人の在席証明。
    

---

## 2. 既存Moodleアーキテクチャの限界と「420時間」への不適合性

Moodleは世界で最も普及しているLMSであるが、その設計思想は「構成主義的教育学」に基づいており、学習者の自律性を重んじる傾向がある。そのため、学習者を「監視」し「拘束」するための機能は、標準コアにはほとんど実装されていない。420時間要件のような厳格なコンプライアンス基準に照らし合わせた場合、以下の構造的な欠陥が浮き彫りになる。

### 2.1 標準ログストア（logstore_standard）のイベント駆動性

Moodleの標準ログシステム（`mdl_logstore_standard_log`）は、基本的に「イベント駆動型」である。つまり、ユーザーが何かのアクション（クリック、ページ遷移、フォーム送信など）を起こした瞬間の点（ポイント）としてのデータのみを記録する。

例えば、ある学習者が「日本語教授法 第1回」というビデオページを10:00に開き、11:00に次のページへ移動したとする。Moodleのログには以下の2行が記録されるのみである。

|**タイムスタンプ**|**イベント名**|**コンテキスト**|
|---|---|---|
|10:00:00|course_module_viewed|日本語教授法 第1回|
|11:00:00|course_module_viewed|日本語教授法 第2回|

システムは、この2つのイベントの差分（1時間）を「滞在時間」として推測することは可能である。しかし、この1時間の間、学習者が本当に画面を見ていたのか、あるいはブラウザを閉じて外出していたのかを区別する情報は、標準ログには一切含まれていない。

さらに、`logstore_standard`テーブルは、サイト内のあらゆる操作を記録するため、データ量が膨大になりやすい。ここに「30秒ごとの視聴確認ログ」などを混入させれば、テーブルサイズは数ギガバイトから数テラバイトのオーダーで肥大化し、Moodle全体のパフォーマンスを著しく低下させるリスクがある。したがって、厳密な時間管理のために標準ログを拡張することは、データベース設計の観点から推奨されない。

### 2.2 既存プラグインの適合性分析

Moodleコミュニティには、学習時間を計測するためのプラグインがいくつか存在するが、いずれも420時間要件の厳格さには耐えられない設計上の限界が存在する。

#### 2.2.1 block_dedication（Course Dedication）

`block_dedication`は、学習時間の推定によく用いられるプラグインである。このプラグインのロジックは、「セッション」の概念に基づいている。連続する2つのクリックの間の時間が、設定された閾値（例えば60分）以内であれば、その期間を学習時間として加算する。

- **欠点1：動画視聴との不適合** 90分の講義動画を視聴する場合、学習者は再生開始ボタンを押した後、90分間何も操作しない可能性がある。この場合、`block_dedication`は次のクリックまでの時間が閾値を超えていると判断し、セッションを切断するか、あるいは過小評価してしまう可能性がある。逆に、クリックさえしていれば、その間何をしていたかは問われないため、精度の低い「推定値」に過ぎない。
    
- **欠点2：ブラウザ状態の無視**
    
    クリック間の時間が計測されるだけであり、その間タブがアクティブであったか、最小化されていたかは考慮されない。
    

#### 2.2.2 mod_attendanceregister

`mod_attendanceregister`は、学習者が自己申告で時間を記録したり、コース内の活動時間を集計したりするモジュールである。

- **欠点：強制力の欠如** このプラグインは主に、オフラインでの学習時間を記録したり、大まかなオンライン時間を集計したりするために設計されている。学習者が動画をスキップしたり、倍速再生したりした場合の「実時間」を強制的に検知し、記録時間を減算するような高度なロジックは実装されていない。また、モバイルアプリでの動作に関する不具合報告もあり、信頼性に課題が残る。
    

### 2.3 SCORMの限界

SCORM（Sharable Content Object Reference Model）は、eラーニングの標準規格として時間追跡機能（`cmi.core.total_time`など）を持っている。しかし、以下の理由から採用は推奨されない。

- **セキュリティの脆弱性**: SCORMの通信はクライアントサイドのJavaScriptに依存しており、ブラウザのコンソールからAPIを直接叩くことで、「完了」ステータスや「学習時間」を容易に偽装できる。
    
- **詳細な行動ログの欠如**: SCORM 1.2では、動画のどの部分を再生し、どこをスキップしたかといった詳細なヒートマップデータをサーバーに送信する標準的な仕組みが弱い。xAPI（Tin Can API）を用いれば解決可能だが、LRS（Learning Record Store）という別個のインフラが必要となり、システム構成が複雑化する。
    

### 2.4 結論：カスタム開発の必要性

以上の分析から、標準機能や既存プラグインの組み合わせだけでは、「420時間要件」のような法的拘束力を持つ厳密な時間管理には対応できないことが明らかである。したがって、**「ハートビート（Heartbeat）」メカニズム**を中心とした、専用のローカルプラグイン（`local_strict_tracking`）およびクライアントサイド監視システムの開発が不可欠である。

---

## 3. クライアントサイド監視アーキテクチャ：ハートビートとPage Visibility API

厳密な時間計測の核心は、サーバー側での推測ではなく、クライアント（ブラウザ）側からの能動的な「生存報告」にある。本章では、学習者のブラウザ内で動作するJavaScript監視エージェントの設計について詳述する。

### 3.1 ハートビート（Heartbeat）メカニズムの設計

ハートビートとは、学習ページが開かれている間、一定間隔（例：30秒ごと）にブラウザからサーバーへ送信される小さな信号（AJAXリクエスト）のことである。この信号が途絶えれば、サーバーは「学習中断」とみなし、時間の積算を停止する。

#### 3.1.1 送信プロトコルとペイロード

ハートビートは単なる「生存確認」以上の情報を運ぶ必要がある。厳密な計測のためには、以下のデータを含めるべきである。

|**パラメータ名**|**データ型**|**説明**|
|---|---|---|
|`session_id`|String|ログイン時に生成されるユニークなセッションID（なりすまし防止）|
|`course_module_id`|Integer|現在学習中の教材ID|
|`timestamp`|Integer|クライアント側の現在時刻（サーバー時刻との乖離検知用）|
|`delta_time`|Integer|前回の送信から経過した実測時間（ミリ秒）|
|`is_tab_active`|Boolean|Page Visibility APIによる判定結果（後述）|
|`video_time`|Float|動画プレイヤーの現在の再生位置（動画教材の場合）|
|`video_rate`|Float|現在の再生速度（1.0, 1.5, 2.0など）|

このデータ構造により、サーバーは単に時間を受け取るだけでなく、「タブが裏側に回っていた時間の報告」や「倍速再生による時間の短縮」を検知し、加算する時間を補正することが可能になる。

#### 3.1.2 送信間隔の最適化

送信間隔は、精度の追求とサーバー負荷のバランスで決定される。

- **10秒間隔**: 非常に高精度だが、サーバーへのリクエスト数が膨大になる（1時間で360リクエスト/人）。
    
- **60秒間隔**: サーバー負荷は軽いが、学習者が59秒でページを閉じた場合、その時間のロスが発生するリスクがある。
    
- **推奨値**: **30秒間隔**。これにより、1時間の学習における誤差を最大でも30秒未満に抑えつつ、サーバー負荷を許容範囲内に収めることが可能である。
    

### 3.2 Page Visibility APIによる「ながら学習」の排除

420時間要件において、「動画を流しっぱなしにして、別タブでYouTubeを見る」行為は許容されない。これを技術的に阻止するのが**Page Visibility API**である。

#### 3.2.1 APIの挙動とステート

Page Visibility APIは、ドキュメントの可視状態を`document.visibilityState`プロパティで提供する。主な状態は以下の通りである。

- `visible`: ページがフォアグラウンドのタブにあり、かつウィンドウが最小化されていない状態。これが唯一、「学習中」と認められる状態である。
    
- `hidden`: ページがバックグラウンドタブにあるか、ウィンドウが最小化されている、またはOSの画面ロックがかかっている状態。
    

#### 3.2.2 実装ロジック

JavaScriptエージェントは、`visibilitychange`イベントをリッスンし、状態遷移をリアルタイムで監視する。

1. **状態監視**: `document.addEventListener("visibilitychange", handler)`を登録。
    
2. **タイマー制御**:
    
    - 状態が`visible`から`hidden`に変わった瞬間、内部の「有効学習タイマー」を一時停止（Pause）する。
        
    - 同時に、サーバーへ「中断（Suspend）」シグナルを送信してもよい。
        
    - 状態が`hidden`から`visible`に戻った瞬間、タイマーを再開（Resume）する。
        
3. **ユーザーへのフィードバック**:
    
    - タブが非表示から復帰した際、画面上に「非アクティブ状態だったため、その間の時間は学習時間に含まれません」という警告モーダルを表示することで、学習者の意識を規律する。
        

この実装により、「ブラウザを開いて放置」するタイプの不正の多く（別タブでの作業）を無効化できる。ただし、別デバイス（スマートフォンなど）での「ながら作業」までは検知できないため、後述するプロクタリング（監視）技術との併用が望ましい。

### 3.3 インプット監視による「ゾンビセッション」の排除

Page Visibility APIだけでは、フォアグラウンドでページを開いたまま寝てしまった場合（ゾンビセッション）を検知できない。これを防ぐため、マウスの動きやキーボード操作を監視する「アクティビティ検知」を導入する。

- **メカニズム**: `mousemove`, `keydown`, `scroll`, `click` イベントをリッスンし、最終操作時刻（`last_activity_time`）を更新する。
    
- **タイムアウト判定**: 現在時刻と`last_activity_time`の差が設定値（例：15分）を超えた場合、システムは「離席中」と判断する。
    
- **強制停止**: 離席判定と同時にハートビート送信を停止し、画面をブラックアウトさせ、「学習を再開するにはボタンを押してください」というダイアログを表示する。ボタンが押されるまで、学習時間の加算は再開されない。
    

---

## 4. 動画教材における厳格制御：Vimeo Player APIの活用

420時間カリキュラムの中核をなす動画教材について、単に再生するだけでなく、その「質」と「量」を担保するための技術的制御について詳述する。ここでは、セキュリティとAPIの豊富さからVimeo Enterpriseを採用することを前提とする。

### 4.1 Vimeo Player APIによる再生制御

iframeで埋め込まれたVimeoプレイヤーを、Moodle側のJavaScript（`player.js`ライブラリ）から完全に制御下に置くことで、以下の不正防止策を講じる。

#### 4.1.1 シーク（早送り）の禁止と検知

学習者が再生バーを操作して動画をスキップする行為（シーク）は、学習時間の欠損に直結するため、厳格に制限する必要がある。

- **イベント監視**: `seeking`（シーク開始）および`seeked`（シーク完了）イベントを監視する。
    
- **ロジック**:
    
    1. システムは常に「現在の最大到達点（`max_played_position`）」を記録しておく。
        
    2. `seeking`イベントが発生した際、移動先のタイムスタンプ（`target_time`）を取得する。
        
    3. もし`target_time > max_played_position`であれば、それは未学習領域へのスキップ（不正）とみなす。
        
    4. **強制送還**: `player.setCurrentTime(max_played_position)`メソッドを即座に実行し、再生位置を元の場所（または最大到達点）に強制的に戻す。
        
    5. **警告表示**: 「この教材では早送りは禁止されています」というトースト通知を表示する。
        

このロジックにより、学習者は「一度見た箇所への巻き戻し」は自由に行えるが、「まだ見ていない箇所へのジャンプ」は物理的に不可能となる。

#### 4.1.2 再生速度（Playback Rate）の監視と時間補正

多くのプレイヤーには倍速再生機能があるが、420時間要件においては、時間短縮は認められない場合が多い。

- **イベント監視**: `playbackratechange`イベントを監視する。
    
- **対応策A（禁止）**: 再生速度が変更された瞬間、`player.setPlaybackRate(1.0)`を実行し、強制的に等倍速に戻す。
    
- **対応策B（減算）**: 倍速再生を利便性として許可するが、記録される学習時間を補正する。
    
    - 計算式：`加算される学習時間 = 実経過時間 / 再生速度`
        
    - 例：10分間の動画を2倍速で5分で視聴した場合、システム上の滞在時間は5分だが、学習完了度（進捗率）としては50%（5分相当）しか認めない。
        
    - この場合、動画を見終わっても「学習時間不足」となり、完了認定されないため、学習者は残りの時間を埋めるために再度視聴する必要が生じる。結果として、等倍速での視聴を促すインセンティブとなる。
        

### 4.2 「実視聴時間」の算出アルゴリズム：Wall-Clock vs Content-Time

ここで技術的に重要な決定事項がある。「学習時間」とは「時計の針が進んだ時間（Wall-Clock Time）」なのか、「動画コンテンツの長さ（Content-Time）」なのかという点である。

- **Wall-Clock Time（実時間）**: 学習者が椅子に座っていた物理的な時間。
    
- **Content-Time（コンテンツ時間）**: 動画の尺。
    

420時間要件は「履修時間」の証明であるため、原則として**Wall-Clock Time**が基準となる。しかし、動画を一時停止して考え込んでいる時間を無限に加算するのは問題がある。

**推奨アルゴリズム**:

1. 動画が`playing`状態であること。
    
2. かつ、`document.visibilityState`が`visible`であること。
    
3. この2条件が満たされている間のみ、サーバー側のカウンターを加算する。
    
4. 動画停止中の時間は「思考時間」として別途記録するが、420時間のカウントには含めない、あるいは「動画尺の+20%まで」といった上限キャップを設けて加算する設計が現実的である。
    

---

## 5. 不正防止の砦：Broadcast Channel APIによる多重ログイン・パラレル受講の阻止

オンライン学習における古典的かつ強力な不正手法が「パラレル受講」である。複数のブラウザタブやウィンドウを開き、同時に複数の講義動画を再生することで、1時間の間に3時間分の学習ログを稼ごうとする行為である。これをクライアントサイドで阻止するために、**Broadcast Channel API**を活用する。

### 5.1 Broadcast Channel APIの実装戦略

Broadcast Channel APIは、同一オリジン（この場合はMoodleサイト）の異なるタブやウィンドウ間でメッセージをやり取りできるブラウザ標準の機能である。これを利用して、タブ間の「排他制御」を実装する。

#### 5.1.1 リーダー選出（Leader Election）パターン

複数のタブが開かれた場合、常に1つのタブだけが「リーダー（アクティブな学習画面）」としての権限を持ち、それ以外のタブは「フォロワー（待機状態）」となるように制御する。

**実装フロー**:

1. **チャンネル開設**: 全てのコースページで`const bc = new BroadcastChannel('moodle_strict_tracking');`を開設する。
    
2. **新規タブの宣言**: 新しく開かれたタブ（タブB）は、「私は新しく開かれた。学習を開始する」というメッセージをブロードキャストする。
    
3. **既存タブの反応**: 既に開かれていたタブ（タブA）はこのメッセージを受信すると、「新しいタブが開始されたため、こちらの学習セッションは一時停止する」と判断し、動画を強制停止（`player.pause()`）し、ハートビート送信を停止する。
    
4. **画面ロック**: タブAの画面全体にオーバーレイを表示し、「別のタブで学習が開始されました。こちらで再開するにはリロードしてください」と警告する。
    

この仕組みにより、学習者はいくらタブを増やしても、同時に進行できる（時間が加算される）講義は常に1つだけに限定される。これはサーバーへの問い合わせを必要とせず、ブラウザ内で完結するため、即応性が高くサーバー負荷もない優れたソリューションである。

### 5.2 サーバーサイドでの二重ログイン防止

ブラウザを変える（ChromeとEdgeを同時に使う）場合、Broadcast Channel APIは機能しない（オリジンやストレージパーティションが異なるため）。これに対しては、Moodleの標準機能とセッション管理で対応する。

- **同時ログイン制限**: `Limit concurrent logins`設定を「1」にする。これにより、別のブラウザでログインした瞬間、前のブラウザのセッションは無効化され、次のハートビート送信時に「セッション切れ」エラーとなり、強制ログアウトされる。
    
- **IPアドレス/User Agent監視**: ハートビート受信時に、前回のリクエストとIPアドレスやUser Agentが急激に変更されていないかをチェックする。
    

---

## 6. 高負荷に耐えうるサーバーサイド・アーキテクチャ

30秒に1回のハートビートを全学習者が送信する環境は、Moodleの標準的なデータベース構成にとって過酷な負荷となる。500人が同時接続すれば毎分1,000回の書き込みが発生し、ログテーブルは爆発的に肥大化する。これを支えるためのバックエンド設計を示す。

### 6.1 カスタムテーブル設計と書き込み最適化

標準の`mdl_logstore_standard_log`は使用せず、専用の軽量テーブル（`mdl_local_strict_tracking`）を設計する。このテーブルは、インデックスを最小限にし、書き込み速度（Insert Rate）を最優先にする。

**テーブル定義案（mdl_local_strict_tracking_raw）**:

- このテーブルは「生データ」の一時保管場所として機能させる。
    

|**カラム名**|**型**|**説明**|
|---|---|---|
|`id`|BIGINT|プライマリキー|
|`userid`|BIGINT|ユーザーID（インデックス）|
|`courseid`|BIGINT|コースID|
|`cmid`|BIGINT|アクティビティID（インデックス）|
|`session_hash`|VARCHAR(64)|セッションの一意性担保|
|`time_logged`|BIGINT|記録時刻|
|`duration`|TINYINT|加算時間（例：30秒なら30）|
|`status_flags`|TINYINT|可視状態や再生速度のフラグ|

### 6.2 データの非同期集計（Aggregation）

生データテーブルにデータが蓄積され続けると、集計クエリが遅くなる。そこで、MoodleのTask API（Cron）を利用した「非同期集計モデル」を採用する。

1. **書き込みフェーズ**: ブラウザからのハートビートは、`mdl_local_strict_tracking_raw`にひたすら追記（Insert）される。Updateは行わない（ロック競合を防ぐため）。
    
2. **集計フェーズ（Scheduled Task）**:
    
    - 5分～1時間に1回、バックグラウンドタスク（Adhoc Task）が起動する。
        
    - Rawテーブルから未処理のデータを読み出し、`userid`と`cmid`ごとに時間を合算する。
        
    - 合算結果を、集計済みテーブル（`mdl_local_strict_tracking_summary`）にUpdateまたはInsertする。
        
    - 処理済みのRawデータは削除（Truncate/Delete）またはアーカイブテーブルへ移動する。
        

この「Write-HeavyなRawテーブル」と「Read-HeavyなSummaryテーブル」の分離により、数千人規模の同時アクセスがあっても、学習進捗の表示や管理者レポートの生成が高速に行える。

### 6.3 データベースチューニング

大量のInsertを捌くため、データベース（MariaDB/MySQL）の設定も見直す必要がある。

- `innodb_flush_log_at_trx_commit = 2`: コミットごとのディスク同期を緩和し、OSキャッシュを活用することで書き込み性能を劇的に向上させる（ACID特性の一部を犠牲にするが、学習ログの性質上、OSクラッシュ時の数秒のデータロスは許容範囲であることが多い）。
    
- `innodb_buffer_pool_size`: サーバーの物理メモリの70-80%を割り当て、インデックスとデータをメモリ上に保持する。
    

---

## 7. 本人確認と監査証跡：なりすまし対策の最終防壁

技術的に「ブラウザが開かれ、動画が再生されている」ことが保証されても、「画面の前にいるのが本人か」という問題は残る。これを解決するのがプロクタリング（Proctoring）技術との統合である。

### 7.1 Webカメラによる間欠的本人確認

常時動画配信は帯域負荷が高すぎるため、間欠的な静止画キャプチャを採用する。

- **実装**: `quizaccess_proctoring`のようなプラグインロジックを流用し、学習画面（動画再生画面）において、ランダムな間隔（例：5分～15分に1回）でWebカメラのスナップショットを撮影し、サーバーに送信する。
    
- **顔認証AI**: 送信された画像に対し、サーバーサイドで顔検出と照合を行う（AWS Rekognition等のクラウドAPIを利用）。
    
    - **判定**: 事前に登録された本人写真と一致するか？
        
    - **不在検知**: カメラに誰も映っていない、または複数人が映っている場合を検知し、アラートを記録する。
        
    - **監査**: これにより、後日、文化庁や監査機関から「この学生は本当に受講したのか？」と問われた際、「はい、この日時のこの講義中に、本人が在席していた画像ログがあります」と証拠を提示できる。
        

---

## 8. 結論：信頼される学習プラットフォームへの道

420時間日本語教師養成課程のeラーニング化は、単なる「動画配信サイト」の構築ではない。それは、対面授業と同等の規律と証明能力を持つ「デジタル教室」の構築である。

本報告書で提案したアーキテクチャは、以下の3層の防御壁によって構成されている。

1. **第1層（ブラウザ制御）**: Page Visibility APIとBroadcast Channel APIにより、学習者の「集中」と「単一作業」を技術的に強制する。
    
2. **第2層（コンテンツ制御）**: Vimeo Player APIにより、教材の「未修了スキップ」や「時間短縮」を物理的に不可能にする。
    
3. **第3層（データ完全性）**: ハートビート記録とデータベースの分離設計により、改ざん不能で高精細な学習ログ（監査証跡）を確保する。
    

このシステムを実装することで、教育機関は「学習の質の担保」と「厳格な修了認定」を両立させ、デジタル時代の日本語教育における新たな信頼基準を確立することができるだろう。これは技術的な挑戦であると同時に、日本語教育の未来を切り拓くための不可欠なインフラ投資である。